{
  "hash": "0f981b857347678e17ed2bcd044c6dc6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Where we're from.\"\neditor: visual\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(googlesheets4)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(maps)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'maps'\n\nThe following object is masked from 'package:purrr':\n\n    map\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(googlesheets4)\n\n\nclass_info <- read_sheet(\"https://docs.google.com/spreadsheets/d/1XOAFQvBcFvhKwEl5xH6l3nRJK2Wk0hWZ18S9kAZclQ0/edit?usp=sharing\") |>\n  janitor::clean_names()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n! Using an auto-discovered, cached token.\n  To suppress this message, modify your code or options to clearly consent to\n  the use of a cached token.\n  See gargle's \"Non-interactive auth\" vignette for more details:\n  <https://gargle.r-lib.org/articles/non-interactive-auth.html>\nℹ The googlesheets4 package is using a cached token for 'nschwab@smith.edu'.\n✔ Reading from \"Fall 2024  Questionnaire (Responses)\".\n✔ Range 'Form Responses 1'.\n```\n\n\n:::\n\n```{.r .cell-code}\n# selecting only the column we are interested in and making it into a vector.\ncountry_vector <- as.vector( \n  class_info |>\n    select(\"what_country_are_you_from\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_maps <- function(country_vector){\n  \n  # Put the body of your function here, don't overthink it.\n  \n}\n# If the line below throws an error its possible your country is not in the database or mispelled. \nclass_maps(country_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# A function for finding appropriate names of countries\n\n# A test vector\nsub_vector<- c(\"China\", \"United States\", \"Afghanistan\")\n\nmap_names <- function(name){\n  # The first line makes sure we have a string\n  name <- as.character(name)\n  \n  # All 1600 names are in the database can be save as follows\n  vector_of_names <- map(plot = FALSE)$names\n  \n  # This gets a vector of boolean values. \n  Truths <- name %in% vector_of_names\n  \n  \n  print(\"The following countries are in the databse\")\n  \n  # This goes back to our original vector and extrance only the true names. \n  print(name[Truths])\n  \n  print(\"The following countries are not in the databse\")\n  \n  # This goes back to our original vector and extrance only the true names. \n  print(name[Truths == FALSE])\n  \n}\nmap_names(sub_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The following countries are in the databse\"\n[1] \"China\"       \"Afghanistan\"\n[1] \"The following countries are not in the databse\"\n[1] \"United States\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#c(\"Aruba\", \"Angola\", \"Afghanistan\") %in% vector_of_names\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}