---
title: "SDS192 Lab 5"
author: Section WRITE YOUR SECTION NUMBER HERE - WRITE YOUR NAME HERE
output:
  html_document
---

```{r, include=FALSE}
# Do not edit this code chunk
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)
```

# Introduction

In terms of data analysis, this lab has one goal: to determine the number of industrial facilities that are currently in violation of **both** the Clean Air Act and the Clean Water Act in California. To achieve this goal, we’re going to have to do some data wrangling and join together some datasets published by the U.S. Environmental Protection Agency (EPA). We’re going to practice applying different types of joins to this data and consider what we learn with each.

# Setting Up Your Environment

1. In your console install the `echor` package:

`install.packages("echor")`

2. Then load the packages and data frames for this lab by running the code below. 

```{r}
library(tidyverse)
library(echor)

echo_air_ca <- 
  echoAirGetFacilityInfo(p_st = "CA",
                         qcolumns = "1,4,5,8,104,105,106,107"
                         ) |>
  select(-SourceID)

echo_water_ca <- 
  echoWaterGetFacilityInfo(p_st = "CA", 
                           qcolumns = "1,4,5,9,184,185,186,187") |>
  select(-SourceID)

echo_air_ca$RegistryID <- as.double(echo_air_ca$RegistryID)
```

3. Run the code below to load the data dictionaries for `echo_air_ca` and `echo_water_ca` into your environment.

```{r}
echo_air_dd <- echoAirGetMeta() |>
  filter(ColumnID %in% c(1,4,5,8,104,105,106,107)) |>
  select(ColumnID, ObjectName, Description)

echo_water_dd <- echoWaterGetMeta() |>
  filter(ColumnID %in% c(1,4,5,9,184,185,186,187)) |>
  select(ColumnID, ObjectName, Description)
```

4. Open both `echo_air_dd` and `echo_water_dd` to review the data dictionaries for these datasets.

# Join Keys

## Ex 1: Identify Key Variables

Write code below to determine the number of unique values for the variables you identify you will join on in each of these data frames. (Hint: Use the `unique()` function to get the number of unique values.)

```{r}
# Write code here for `echo_air_ca`

# Write code here for `echo_water_ca`

```

If you’ve done this correctly, you’ll learn that there are 2614 unique values in echo_air_ca’s key variable. You’ll also learn that there are 28355 unique values in echo_water_ca’s key variable.

…but if you look in your environment, there are 2808 rows in `echo_air_ca`, and there are 30939 rows in `echo_water_ca`. This means that the key variable must repeat, and that certain facilities are represented more than once in each of these data frames.

This happens because the EPA defines a facility in different ways depending on what laws it is regulated by. What counts as one facility in the Clean Air Act may count as two or three facilities in the Clean Water Act, but there is only one ID to document the relationships between them. This means that the same ID may show up a few times for different parts of the same facility. Check out some of the duplicating rows via my code below. Notice how multiple facilities - sometimes with entirely different names can be associated with the same RegistryID?

```{r}
echo_air_ca |>
  group_by(RegistryID) |>
  filter(n() > 1) |>
  arrange(RegistryID) |>
  head()
```

Later we will talk about what happens when we join two data frames that both have repeating keys, but for now, we’re going aggregate both of these data frames so that each Registry ID only appears once. Basically, we are going to write code to say: if any of the rows pertaining to this Registry ID document certain kinds of violations, set the violation flag for that facility to 1.

## Ex 2: Aggregating Data Frames

In the code below, for each of the data frames, you should group the data by `RegistryID` and then summarize by returning the `max()` value in `CurrSvFlag`, `ViolFlag`, `CurrVioFlag`, `Insp5yrFlag` for each group. Store the results in `echo_air_ca_agg` and `echo_water_ca_agg`. Note how many rows are in `echo_air_ca_agg` and `echo_water_ca_agg`. It should match the number of unique values in `RegistryID` that you calculated above.

```{r}
echo_air_ca_agg <- echo_air_ca |>
  _________ |>             #group by RegistryID
  _________(                #Summarize the following:
    CurrSvFlag = _________, #Calculate max value in CurrSvFlag
    ViolFlag = _________,   #Calculate max value in ViolFlag
    CurrVioFlag = _________,#Calculate max value in CurrVioFlag
    Insp5yrFlag = _________ #Calculate max value in Insp5yrFlag
  )

echo_water_ca_agg <- #Copy and adjust code above to create echo_water_ca_agg
```

# Joins

So now we have two data frames with unique registry IDs and variables indicating whether the facility has a current significant violation, whether it has had a violation in the past three years, whether it has a current violation, and whether it has been inspected in the past 5 years.

Now we want to join these two data frames together, so that we can check which facilities have violations to both the Clean Air Act and the Clean Water Act.

## Ex 3: Joining Data Frames

Write code below to perform four kinds of joins - a left join, a right join, an inner join, and a full join. `echo_water_ca_agg` should be in the first position, and `echo_air_ca_agg` should be joined onto it. I’ve started that for you in the commented code below.

```{r}
#joined_left <- echo_water_ca_agg |> 
  

#joined_right <- echo_water_ca_agg |> 
  

#joined_inner <- echo_water_ca_agg |> 
  

#joined_full <- echo_water_ca_agg |>
  
```

Check out the first six rows of `joined_full` below and note what happens when a `RegistryID` is present in one data frame but not in the other. We see data values in the columns associated with the data frame where the `RegistryID` was present, and `NA` values in the columns associated with the data frame where the `RegistryID` was not present. This is how we come to have so many extra rows in `joined_full`.

```{r}
joined_full |> 
  head()
```

With `joined_inner`, any rows associated with a `RegistryID` that doesn’t appear in both data frames get dropped. Check out the number of rows in `joined_inner`.

```{r}
nrow(joined_inner)
```

This represents the number of Registry IDs that were present in **both** `echo_water_ca_agg` and `echo_air_ca_agg`.

## Ex 4: Understanding Different Joins

The three statements below are incorrect. Correct my statements below about these joins.

```{r}
paste(nrow(joined_full), "represents the number of Registry IDs present in echo_air_ca_agg")

paste(nrow(joined_left), "represents the number of Registry IDs present in either echo_air_ca_agg or echo_water_ca_agg")

paste(nrow(joined_right), "represents the number of Registry IDs present in echo_water_ca_agg")
```

From here on out, since we are only interested in the facilities with violations to both Acts, we are going to focus on `joined_inner`. Let’s remove the rest of the joined data frames from our environment.

```{r}
rm(joined_full, joined_left, joined_right)
```

You might note at this point that it can be difficult to tell which columns are associated with which environmental laws. This is because originally in both data frames, the variables we are most interested in (`CurrSvFlag`, `ViolFlag`, `CurrVioFlag`, `Insp5yrFlag`) shared the same names. When we joined these two data frames together, `R` opted to distinguish between them by tacking a `.x` onto the variable names for the data frame in the first position in the join and a `.y` onto the variable names for the data frame in the second position in the join. Let’s give each of these variables more meaningful names. 

## Ex 5: Renaming Columns

In my code below rename the remaining columns to differentiate between the column names from the two original data frames.

```{r}
joined_inner_renamed <-
  joined_inner |>
  rename(
    CurrSvFlag_water = CurrSvFlag.x,
    ViolFlag_water = ViolFlag.x 
    #Rename remaining columns here. Be sure to separate by comma. There are six more to go!
  )
```

## Ex 6: Subsetting Data Frames

Now that we have a cleaned up data frame, use a data wrangling verb to subset the data frame to the rows where a `RegistryID` has a current violation to both the Clean Water Act and Clean Air Act. Repeat these steps to determine which Registry IDs have a significant violation to both Acts. I recommend running this on `joined_inner_renamed`.

Once you’ve run these codes, open both `echo_air_ca` and `echo_water_ca` by clicking on the data frames in your environment. Search for a few of the Registry IDs that appeared in your analysis to identify the names and locations of the facilities.

```{r}
# Write wrangling code here for current violations 


# Write wrangling code here for significant violations

```

# Many-to-Many Joins

We don’t know much about these facilities because we lost a lot of critical information (e.g. the facility’s name and location) when aggregating our data by `RegistryID` above. At the time, we couldn’t aggregate by name because certain facilities sharing the same `RegistryID` had different names! Aggregating by name would have meant that we’d still have repeating Registry Ids in the data frame - one for each different version of the facility’s name.

The truth is though that we didn’t **technically have to** ensure that the `RegistryID` didn’t repeat. We can still join data frames in instances where the join key repeats in both data frames. This is called performing a many-to-many join because we are joining many of the same key in one data frame to many of the same key in another data frame. It’s important to pay attention to what happens when we make this join. Let’s look at an example: the facility with Registry ID 110001181186.

```{r}
echo_air_ca |>
  filter(RegistryID == 110001181186)
```

```{r}
echo_water_ca |>
  filter(RegistryID == 110001181186)
```

In `echo_air_ca`, this `RegistryID` appears three times in the data frame, and in `echo_water_ca`, this `RegistryID` appears twice in the data frame. In each instance, the facility has a different name. What happens to facility 110001181186 when we perform a many-to-many join?

```{r}
echo_water_ca |> 
  inner_join(echo_air_ca, by = "RegistryID") |> 
  filter(RegistryID == 110001181186) |>
  select(CWPName, AIRName, RegistryID)
```

This inner join created six rows for facility 110001181186. This is because `R` matched each of the three rows for facility 110001181186 in `echo_air_ca` with the two rows for facility 110001181186 in `echo_water_ca` (and 3 rows * 2 rows = 6 rows).

This is one of the reasons why it is important to understand the context of datasets and their units of observation. Here we’ve joined these rows together as if they represented matching facilities. …but just by looking at this output we know that PLATFORM A is going to be physically different than DOS CUADRAS/SOUTH COUNTY/PLATFORM B, and PLATFORM B is going to be physically different than DOS CUADRAS/SOUTH COUNTY/PLATFORM C. The only thing that they all share is that they are sub-parts of the facility with the `RegistryID` 110001181186. Ultimately the units of observation don’t match across these two data frames because Clean Air Act and Clean Water Act delineate facilities differently.

## Ex 7: Weekly Reflections

Fill out this week's reflections Google form to receive credit.
